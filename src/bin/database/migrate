#!/usr/bin/env node
import fs           						from 'fs'
import minimist     						from 'minimist'
import sequence 							from 'when/sequence'
import schema								from './../../config/database/schema'
import { keys, map }						from 'lodash'
import { kernel, bundleManager, config }	from './../../bootstrap.js'

let argv = minimist( process.argv.slice( 2 ) )

const container             = bundleManager.container
const message               = container.getComponent( 'Console' )
let schemaDatabaseService 	= container.getService( 'database.schema' )

const titleError		= "Error when updating database"
const consequenceError	= "Migration aborted."

/*
 * Functions
 */
function raiseError( err ) {
	message.error({
		title: titleError,
		message: err,
		consequence: consequenceError,
		exit: 0
	})
}

function dropTables() {
    let tables = []
    let tableNames = keys( schema )

    // we need to reverse tables schema, to delete in first table which contains fk and not the parents, otherwise error will occur because of fk.
    tableNames.reverse()
    tables = map( tableNames, tableName => {
      return function () {
        return schemaDatabaseService.dropTable( tableName )
      }
    })

    return sequence( tables )
}

function createTables () {
  let tables = []
  const tableNames = keys( schema )

  tables = map( tableNames, tableName => {
    return () => {
      return schemaDatabaseService.createTable( tableName, schema[ tableName ] )
    }
  })

  return sequence( tables )
}

function migrate( standalone ) {
	dropTables()
	.then( () => {
		return new Promise( (resolve, reject) => {
			createTables()
			.then( () => {
				const exitAfterSuccess = standalone
				message.success( "Schema updated.", exitAfterSuccess )
				resolve()
			})
			.catch( error => {
				raiseError( error )
				reject( error )
			})
		})
	})
	.catch( error => {
		raiseError( error )
	})
}


function updateDatabaseNameInConfig() {
	const databaseConfigFilePath = __dirname + '/../../../config/database/connector/knex.js'

	fs.readFile( databaseConfigFilePath, { encoding: 'utf8' }, ( error, data ) => {
		if ( error ) {
			errorUpdatingDatabaseConfigProperty( error )
		} else {
	   		const dataUpdated = data.replace( /database\s*:\s*\w+/, 'database : params.connection.database' )

			fs.writeFile( databaseConfigFilePath, dataUpdated, 'utf8', error => {
				if ( error ) {
					errorUpdatingDatabaseConfigProperty( error )
				} else {
					/*
					 * Configuration succefully edited
					 * we reconnect database to new schema
					 */
					delete require.cache[ require.resolve( __dirname + '/../../../config/database/database' ) ]

					const clearCache = true
					schemaDatabaseService = container.getService( 'database.schema', clearCache )

					/*
					 * Continue migration
					 */
					migrate()
				}
		  	})
		}
	})

	function errorUpdatingDatabaseConfigProperty( error ) {
		message.error({
			title: 'Error when trying to edit the database connection property into ~/src/config/config.js path',
			message: error,
			consequence: 'Migration aborted.',
			exit: 0
		})
	}
}


/*
 * Code executed first
 * Code permits create database, and we have to change connection string into knex conf file
 * Not finalized
 */
// schemaDatabaseService.createSchema( config.database.connection.database )
// .then( schema => {
// 	/*
// 	 * Database created for first time, we set the database config property into ~/src/config/config.js -> database.connection.database
// 	 */
//  	/*
// 	 *
// 	 * message.success( 'Database ' + config.database.connection.database + ' created. Think to check database encoding.' )
// 	 * updateDatabaseNameInConfig()
// 	 */
// })
// .catch( error => {
// 	migrate()
// })

(function() {
	'use strict'

	let standalone = true

	if ( false === process.argv.standalone ) {
		standalone = false
	}

	if ( standalone ) {
		migrate()
	} else {
		return migrate()
	}
}())
