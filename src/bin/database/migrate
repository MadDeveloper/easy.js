#!/usr/bin/env node
import fs           	from 'fs'
import { keys, map }	from 'lodash'
import minimist     	from 'minimist'
import sequence 		from 'when/sequence'
import config       	from './../../config/config'
import App          	from './../../bootstrap.js'

let argv    = minimist( process.argv.slice( 2 ) )
let cliMode = true

const app                   = new App( config, cliMode )
const kernel                = app.kernel
const bundleManager         = app.bundleManager
const container             = bundleManager.container
const message               = container.getComponent( 'Message' )
let schemaDatabaseService = container.getService( 'database.schema' )

const titleError		= "Error when updating database"
const consequenceError	= "Migration aborted."

/*
 * Functions
 */
function raiseError( err ) {
	message.error({
		title: titleError,
		message: err,
		consequence: consequenceError,
		exit: 0
	})
}

function dropTables() {
    let tables = []
    let tableNames = keys( Schema )

    // we need to reverse tables schema, to delete in first table which contains fk and not the parents, otherwise error will occur because of fk.
    tableNames.reverse()
    tables = map( tableNames, tableName => {
      return function () {
        return schemaDatabaseService.dropTable( tableName )
      }
    })

    return sequence( tables )
}

function createTables () {
  let tables = []
  const tableNames = keys( Schema )

  tables = map( tableNames, tableName => {
    return () => {
      return schemaDatabaseService.createTable( tableName, schema[ tableName ] )
    }
  })

  return sequence( tables )
}

function migrate() {
	dropTables()
	.then( () => {
		let standalone = true

		if ( false === process.argv.standalone ) {
			standalone = false
		}

		if ( standalone ) {
			createTables()
			.then( () => {
				message.success( "Schema updated.", true )
			})
			.catch( error => {
				raiseError( error )
			})
		} else {
			const callback = process.argv.callback || function() {}

			createTables()
			.then( () => {
				message.success( "Schema updated." )
				callback()
			})
			.catch( error => {
				raiseError( error )
				callback()
			})
		}
	})
	.catch( error => {
		raiseError( error )
	})
}


function updateDatabaseNameInConfig() {
	const databaseConfigFilePath = __dirname + '/../../../config/database/connector/knex.js'

	fs.readFile( databaseConfigFilePath, { encoding: 'utf8' }, ( error, data ) => {
		if ( error ) {
			errorUpdatingDatabaseConfigProperty( error )
		} else {
	   		const dataUpdated = data.replace( /database\s*:\s*\w+/, 'database : params.connection.database' )

			fs.writeFile( databaseConfigFilePath, dataUpdated, 'utf8', error => {
				if ( error ) {
					errorUpdatingDatabaseConfigProperty( error )
				} else {
					/*
					 * Configuration succefully edited
					 * we reconnect database to new schema
					 */
					delete require.cache[ require.resolve( __dirname + '/../../../config/database/database' ) ]

					const clearCache = true
					schemaDatabaseService = container.getService( 'database.schema', clearCache )

					/*
					 * Continue migration
					 */
					migrate()
				}
		  	})
		}
	})

	function errorUpdatingDatabaseConfigProperty( error ) {
		message.error({
			title: 'Error when trying to edit the database connection property into ~/src/config/config.js path',
			message: error,
			consequence: 'Migration aborted.',
			exit: 0
		})
	}
}


/*
 * Code executed first
 */
schemaDatabaseService.createSchema( config.database.connection.database )
.then( schema => {
	/*
	 * Database created for first time, we set the database config property into ~/src/config/config.js -> database.connection.database
	 */
 	message.success( 'Database ' + config.database.connection.database + ' created. Think to check database encoding.' )
	updateDatabaseNameInConfig()
})
.catch( error => {
	migrate()
})
