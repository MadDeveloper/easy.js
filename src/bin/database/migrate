#!/usr/bin/env node
import fs           								from 'fs'
import minimist     								from 'minimist'
import sequence 									from 'when/sequence'
import schema										from './../../config/database/schema'
import { keys, map }								from 'lodash'
import { kernel, bundleManager, config, container }	from './../../bootstrap.js'

const argv = minimist( process.argv.slice( 2 ) )

const cli               	= container.getComponent( 'Console' )
let schemaDatabaseService 	= container.getService( 'database.schemaBuilder' )

const titleError		= "Error when updating database"
const consequenceError	= "Migration aborted."

/*
 * Functions
 */
function raiseError( err ) {
	cli.error({
		title: titleError,
		message: err,
		consequence: consequenceError,
		exit: 0
	})
}

function dropTables() {
    let tables = []
    let tableNames = keys( schema )

    // we need to reverse tables schema, to delete in first table which contains fk and not the parents, otherwise error will occur because of fk.
    tableNames.reverse()
    tables = map( tableNames, tableName => {
      return function () {
        return schemaDatabaseService.dropTable( tableName )
      }
    })

    return sequence( tables )
}

function createTables () {
  let tables = []
  const tableNames = keys( schema )

  tables = map( tableNames, tableName => {
    return () => {
      return schemaDatabaseService.createTable( tableName, schema[ tableName ] )
    }
  })

  return sequence( tables )
}

function migrate( standalone ) {
	return new Promise( (resolve, reject) => {
		dropTables()
		.then( createTables )
		.then( () => {
			const exitAfterSuccess = standalone
			cli.success( "Schema updated.", exitAfterSuccess )
			resolve()
		})
		.catch( error => {
			raiseError( error )
			reject( error )
		})
	})
}


function updateDatabaseNameInConfig() {
	const databaseConfigFilePath = `${__dirname}/../../../config/database/connector/knex.js`

	fs.readFile( databaseConfigFilePath, { encoding: 'utf8' }, ( error, data ) => {
		if ( error ) {
			errorUpdatingDatabaseConfigProperty( error )
		} else {
	   		const dataUpdated = data.replace( /database\s*:\s*\w+/, 'database : params.connection.database' )

			fs.writeFile( databaseConfigFilePath, dataUpdated, 'utf8', error => {
				if ( error ) {
					errorUpdatingDatabaseConfigProperty( error )
				} else {
					/*
					 * Configuration succefully edited
					 * we reconnect database to new schema
					 */
					delete require.cache[ require.resolve( `${__dirname}/../../../config/database/database` ) ]

					const clearCache = true
					schemaDatabaseService = container.getService( 'database.schemaBuilder', clearCache )

					/*
					 * Continue migration
					 */
					migrate()
				}
		  	})
		}
	})

	function errorUpdatingDatabaseConfigProperty( error ) {
		cli.error({
			title: 'Error when trying to edit the database connection property into ~/src/config/config.js path',
			message: error,
			consequence: 'Migration aborted.',
			exit: 0
		})
	}
}


/*
 * Code executed first
 * Code permits create database, and we have to change connection string into knex conf file
 * Not finalized
 */
// schemaDatabaseService.createSchema( config.database.connection.database )
// .then( schema => {
// 	/*
// 	 * Database created for first time, we set the database config property into ~/src/config/config.js -> database.connection.database
// 	 */
//  	/*
// 	 *
// 	 * cli.success( 'Database ' + config.database.connection.database + ' created. Think to check database encoding.' )
// 	 * updateDatabaseNameInConfig()
// 	 */
// })
// .catch( error => {
// 	migrate()
// })

;(function() {
	'use strict'

	const standalone = false === process.argv.standalone ? true : false

	if ( standalone ) {
		migrate()
	}
}())

export { migrate }
