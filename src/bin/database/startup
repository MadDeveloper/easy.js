#!/usr/bin/env node
import execsql          from 'execsql'
import { indexOf, has }	from 'lodash'
import minimist     	from 'minimist'
import config       	from './../../config/config'
import schema			from './../../config/database/schema'
import App          	from './../../bootstrap.js'

let argv    = minimist( process.argv.slice( 2 ) )
let cliMode = true

const app                   = new App( config, cliMode )
const bundleManager         = app.bundleManager
const container             = bundleManager.container
const message               = container.getComponent( 'Message' )
let schemaDatabaseService 	= container.getService( 'database.schema' )

const dbConfig = {
	host: config.database.connection.host,
	user: config.database.connection.user,
	password: config.database.connection.password
}

const titleError		= "Error when initializing roles and users"
const consequenceError	= "Initialization aborted."

if ( indexOf( 'lite', argv._ ) !== -1 || argv.lite ) {
	/*
	 * Standalone mode, we first truncate users and then roles table, and init roles and users again
	 */
	truncateRolesAndUsersTables()
	.then( () => {
		startup()
	})
	.catch( error => {
		raiseError( error )
	})
} else {
	/*
	 * Normal mode, we call migrate before init roles and users
	 * Indicate to migrate we are waiting him to return promise with standalone sets as false
	 */
	process.argv.standalone = false

	const migrate = require( './migrate' )

	migrate
	.then( () => {
		startup()
	})
}

function raiseError( err ) {
	message.error({
		title: titleError,
		message: err,
		consequence: consequenceError,
		exit: 0
	})
}

function truncateRolesAndUsersTables() {
	return new Promise( ( resolve, reject ) => {
		const usersTableName = has( schema, 'users' ) ? 'users' : has( schema, 'user' ) ? 'user' : false
		const rolesTableName = has( schema, 'roles' ) ? 'roles' : has( schema, 'role' ) ? 'role' : false

		if ( false === usersTableName ) {
			raiseError( 'Users table not found into schema.js, possibilities tried: users, user' )
		} else if ( false === rolesTableName ) {
			raiseError( 'Roles table not found into schema.js, possibilities tried: roles, role' )
		}

		const tables = {
			users: usersTableName,
		  	roles: rolesTableName
		}

		const promiseTruncateUsersTable = schemaDatabaseService.truncateTable( tables.users )
		const promiseClearRolesTable = schemaDatabaseService.clearTable( tables.roles )

	  	promiseTruncateUsersTable
		.then( promiseClearRolesTable )
		.catch( error => {
			reject( error )
		})
	})
}

function startup() {
	const rolesTable 	= schema.roles
	const rolesToAppend	= {
		admin: {
			id: 1,
			name: 'Administrator',
			slug: 'administrator'
		},

		user: {
			id: 2,
			name: 'User',
			slug: 'user'
		}
	}

	const usersTable 	= schema.users
	const usersToAppend	= {
		admin: {
			id: 1,
			username: 'admin',
			email: 'admin@easy.com',
			password: 'K18necxhS4G;ur4', // http://randomkeygen.com/ -> Strong passwords
			role_id: rolesToAppend.admin.id
		},

		john: {
			id: 2,
			username: 'johndoe',
			email: 'john.doe@easy.com',
			password: '2Z7P97Y3o829gnr',
			role_id: rolesToAppend.user.id
		}
	}

	const sqlUse = 'use ' + config.database.connection.database + ';'

	/*
	 * Roles part
	 */
	let sqlRoles = 'insert into roles '

	const rolesTablePropertiesLength	= Object.keys( rolesTable ).length
	let currentRolesTableProperty 		= 1

	sqlRoles += '('
	Object.keys( rolesTable ).forEach( column => {
		sqlRoles += column

		if ( currentRolesTableProperty++ < rolesTablePropertiesLength ) {
			sqlRoles += ', '
		}
	})
	sqlRoles += ') values '

	const rolesLength	= Object.keys( rolesToAppend ).length
	let currentRole 	= 1

	Object.keys( rolesToAppend ).forEach( role => {
		const rolePropertiesLength 	= Object.keys( rolesToAppend[ role ] ).length
		let currentRoleProperty		= 1

		sqlRoles += '('
		Object.keys( rolesToAppend[ role ] ).forEach( roleProperty => {
			sqlRoles += ( typeof rolesToAppend[ role ][ roleProperty ] !== 'number' ) ? '"' + rolesToAppend[ role ][ roleProperty ] + '"' : rolesToAppend[ role ][ roleProperty ]

			if ( currentRoleProperty++ < rolePropertiesLength ) {
				sqlRoles += ', '
			}
		})
		sqlRoles += ')'

		if ( currentRole++ < rolesLength ) {
			sqlRoles += ', '
		} else {
			sqlRoles += ';'
		}
	})


	/*
	 * Users part
	 */
	let sqlUsers    = 'insert into users '

	const usersTablePropertiesLength	= Object.keys( usersTable ).length
	let currentUsersTableProperty		= 1

	sqlUsers += '('
	Object.keys( usersTable ).forEach( column => {
		sqlUsers += column

		if ( currentUsersTableProperty++ < usersTablePropertiesLength ) {
			sqlUsers += ', '
		}
	})
	sqlUsers += ') values '

	const usersLength	= Object.keys( usersToAppend ).length
	let currentUser 	= 1

	Object.keys( usersToAppend ).forEach( user => {
		const userPropertiesLength 	= Object.keys( usersToAppend[ user ] ).length
		let currentUserProperty		= 1

		sqlUsers += '('
		Object.keys( usersToAppend[ user ] ).forEach( userProperty => {
			sqlUsers += ( typeof usersToAppend[ user ][ userProperty ] !== 'number' ) ? '"' + usersToAppend[ user ][ userProperty ] + '"' : usersToAppend[ user ][ userProperty ]

			if ( currentUserProperty++ < userPropertiesLength ) {
				sqlUsers += ', '
			}
		})
		sqlUsers += ')'

		if ( currentUser++ < usersLength ) {
			sqlUsers += ', '
		} else {
			sqlUsers += ';'
		}
	})

	execsql.config( dbConfig )
		.exec( sqlUse, ( err, results ) => {
	        if ( err ) {
				raiseError( err )
	        }
	    })
		.exec( sqlRoles, ( err, results ) => {
	        if ( err ) {
				raiseError( err )
	        }
		})
		.exec( sqlUsers, ( err, results ) => {
	        if ( err ) {
				raiseError( err )
	        } else {
				message.success( "Database initialized.", true )
	        }
	        process.exit()
		})
}
