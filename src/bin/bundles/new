#!/usr/bin/env node
import fs                                   from 'fs'
import walk                                 from 'walk'
import path                                 from 'path'
import minimist                             from 'minimist'
import { question }                         from 'readline-sync'
import { indexOf }                          from 'lodash'
import { kernel, bundleManager, container } from './../../bootstrap.js'

let argv = minimist( process.argv.slice( 2 ) )

const cli                   = container.getComponent( 'Console' )
const schemaDatabaseService = container.getService( 'database.schema' )
const stringLibrary         = container.getLibrary( 'string' )

cli.error({
    title: "Test",
    message: "Test",
    exit: 0
})

const nameBundleFromArgv    = argv._[ 0 ] || argv.name || argv.n || ""

if ( nameBundleFromArgv.length > 0 ) {
    const bundlesTestPath = `${__dirname}/../../../src/test/bundles`

    const positiveAnswers       = [ 'y', 'ye', 'yes' ]
    const negativeAnswers       = [ 'n', 'no' ]
    const bundlesPath           = `${__dirname}/../../../src/bundles`
    const skeletonBundlePath    = `${bundlesPath}/skeleton`

    let nameBundle              = stringLibrary.cleanSpaces( nameBundleFromArgv )
    let nameBundleCapitalized   = nameBundle.capitalizeFirstLetter()
    let nameBundleDecapitalized = nameBundle.decapitalizeFirstLetter()
    let bundleCreatingPath      = `${bundlesPath}/${nameBundleDecapitalized}`

    let tableName   = ''
    let properties  = {}

    const availablesColumnType  = [ 'increments', 'integer', 'bigInteger', 'text', 'string', 'float', 'decimal', 'boolean', 'date', 'datetime', 'time', 'timestamp' ]
    const specialColumnType     = [ 'increments', 'integer', 'bigInteger', 'text', 'string', 'float', 'decimal' ]
    const pathDatabaseSchema    = `${kernel.path.config}/database/schema.js`

    /*
     * Check if bundle isn't defined yet
     */
    fs.lstat( `${bundlesPath}/${nameBundleDecapitalized}`, ( err, stats ) => {
        if ( !err && stats.isDirectory() ) {
            cli.error({
                title: "Impossible to create bundle",
                message: `${nameBundleCapitalized} bundle already exists.`,
                consequence: "Creation aborted.",
                exit: 0
            })
        } else {
            checkIfSkeletonIsDefined()
        }
    })

    function checkIfSkeletonIsDefined() {
        /*
         * Check if Skeleton bundle is defined
         */
        fs.lstat( skeletonBundlePath, ( err, stats ) => {
            if ( err || !stats.isDirectory() ) {
                cli.error({
                    title: "Impossible to create bundle",
                    message: "Skeleton bundle isn't defined.",
                    consequence: "Creation aborted.",
                    exit: 0
                })
            } else {
                askForTable()
            }
        })
    }

    function askForTable() {
        const createAssociatedTable = question( 'Do you want create an associated table into database? (y/n) ' ).trim().toLowerCase()

        if ( indexOf( positiveAnswers, createAssociatedTable ) !== -1 ) {
            /*
             * Table associated requested
             */
            checkExistanceOfSchemaFile()
            .then( () => {
                askForTableName()
            })
        } else if ( indexOf( negativeAnswers, createAssociatedTable ) !== -1 ) {
            /*
             * No table associated requested
             */
            createBundleDirectory()
        } else {
            askForTable()
        }
    }

    function askForTableName() {
        cli.line()

        const defaultTableName  = `${stringLibrary.asSnakeCase( nameBundleDecapitalized )}s`
        const answerTableName   = stringLibrary.asSnakeCase( question( `Table name (default: ${defaultTableName}): ` ) )

        tableName = ( answerTableName.length > 0 ) ? answerTableName : defaultTableName

        askForProperties()
    }

    function askForProperties() {
        cli.line()

        /*
         * We ask for properties
         */
        const columnName        = stringLibrary.asSnakeCase( question( 'Column name (let empty if the table is complete): ' ) )
        const propertiesLength  = Object.keys( properties ).length

        if ( columnName.length === 0 && propertiesLength === 0 ) {
            askForTable()
        } else if ( columnName.length === 0 && propertiesLength > 0 ) {
            createTable()
        } else {
            const columnType = stringLibrary.cleanAccents( question( `Column type: (availables: ${availablesColumnType.join( ', ' )}): ` ).toLowerCase().trim() )

            if ( indexOf( availablesColumnType, columnType ) !== -1 ) {
                /*
                 * Everything is ok, we push new column
                 */
                properties[ columnName ] = {}
                properties[ columnName ].type = columnType

                /*
                 * Special property ? Ask for more details
                 */
                if ( indexOf( specialColumnType, columnType ) !== -1 ) {
                    askDetailsForSpecialColumnType( columnType, columnName )
                }

                askForProperties()
            } else {
                cli.error({
                    title: "Column type not valid",
                    message: `Column type can be: ${availablesColumnType.join( ', ' )}`
                })
                askForProperties()
            }
        }
    }

    function askDetailsForSpecialColumnType( type, columnName ) {
        let property = properties[ columnName ]

        switch ( type ) {

            case 'increments':
                const anwserDefineAsPrimary = question( 'Define as primary? (y/n) ' ).trim().toLowerCase()

                if ( indexOf( positiveAnswers, anwserDefineAsPrimary ) !== -1 ) {
                    /*
                     * Define as primary
                     */
                    property.primary = true
                } else if ( indexOf( negativeAnswers, anwserDefineAsPrimary ) === -1 ) {
                    /*
                     * Not recognized answer
                     */
                    askDetailsForSpecialColumnType( type, columnName )
                }

                askForUniqueColumn( columnName )
                property.nullable = false
                break

            case 'integer':
            case 'bigInteger':
                const answerIsAReference = question( 'Define as reference (foreign key)? (y/n) ' ).trim().toLowerCase()

                if ( indexOf( positiveAnswers, answerIsAReference ) !== -1 ) {
                    /*
                     * Define as reference
                     */
                    property.unsigned = true

                    const answerReference = question( 'Table.ColumnId as reference (exemple: roles.id): ' ).trim().toLowerCase()

                    if ( answerReference.indexOf( '.' ) !== -1 && answerReference.match( /^\w+\.\w+$/ ) ) {
                        property.references = answerReference

                        const validsOnEventAction   = [ 'restrict', 'cascade', 'set null', 'no action' ]
                        let defaultOnEventAction    = 'restrict'

                        /*
                         * OnDelete
                         */
                        const answerOnDelete = question( `On delete action: (${validsOnEventAction.join( ', ' )}, default: ${defaultOnEventAction}) `).trim().toLowerCase()

                        if ( indexOf( validsOnEventAction, answerOnDelete ) !== -1 ) {
                            property.onDelete = answerOnDelete
                        } else {
                            property.onDelete = defaultOnEventAction
                        }

                        /*
                         * OnUpdate
                         */
                        const answerOnUpdate = question( `On update action: (${validsOnEventAction.join( ', ' )}, default: ${defaultOnEventAction}) `).trim().toLowerCase()

                        if ( indexOf( validsOnEventAction, answerOnUpdate ) !== -1 ) {
                            property.onUpdate = answerOnUpdate
                        } else {
                            property.onUpdate = defaultOnEventAction
                        }
                    } else {
                        /*
                         * Wrong reference
                         */
                        delete property.unsigned
                        cli.error({
                            title: "Wrong reference",
                            message: `Reference -> ${answerReference} is not a valid reference.`
                        })
                        askDetailsForSpecialColumnType( type, columnName )
                    }
                }

                askForUniqueColumn( columnName )
                askForNullableColumn( columnName )
                break

            case 'text':
                const validsTextType  = [ 'text', 'mediumtext', 'longtext' ]
                const defaultTextType = 'text'
                const anwserTypeOfText = question( `Which kind of text? ( ${validsTextType.join( ', ' )}, default: ${defaultTextType}) ` ).trim().toLowerCase()

                if ( indexOf( validsTextType, anwserTypeOfText ) !== -1 ) {
                    property.fieldtype = anwserTypeOfText
                } else {
                    property.fieldtype = defaultTextType
                }

                askForNullableColumn( columnName )
                break

            case 'string':
                const minLength = 1, maxLength = 255
                const answerMaxLength = question( `Max length (${minLength}-${maxLength}, default: ${maxLength}): ` ).trim()

                if ( !isNaN( answerMaxLength ) && answerMaxLength >= minLength && answerMaxLength <= maxLength ) {
                    /*
                     * Ok
                     */
                    property.maxlength = parseInt( answerMaxLength )
                } else if ( !isNaN( answerMaxLength ) ) {
                    /*
                     * Not in range, default value applicated
                     */
                    property.maxlength = maxLength
                } else {
                    /*
                     * Wrong answer, we ask again
                     */
                    askDetailsForSpecialColumnType( type, columnName )
                }

                askForUniqueColumn( columnName )
                askForNullableColumn( columnName )
                break

            case 'float':
            case 'decimal':
                const defaultPrecision = 8
                const answerPrecision = question( `Precision (integer, default: ${defaultPrecision}): ` ).trim()

                if ( answerPrecision.length === 0 || isNaN( answerPrecision ) || !isFinite( answerPrecision ) ) {
                    property.precision = defaultPrecision
                } else {
                    property.precision = parseInt( answerPrecision )
                }

                if ( 'decimal' === type ) {
                    /*
                     * Ask for scale
                     */
                    const defaultScale = 2
                    const answerScale = question( `Scale (integer, default: ${defaultScale}): ` ).trim()

                    if ( answerScale.length === 0 || isNaN( answerScale ) || !isFinite( answerScale ) ) {
                        property.scale = defaultScale
                    } else {
                        property.scale = parseInt( answerScale )
                    }
                }

                askForNullableColumn( columnName )
                break
        }
    }

    function askForNullableColumn( columnName ) {
        const answerNullable = question( 'Define as nullable? (y/n) ' ).trim().toLowerCase()

        if ( indexOf( positiveAnswers, answerNullable ) !== -1 ) {
            /*
             * Define as nullable
             */
            properties[ columnName ].nullable = true
        } else if ( indexOf( negativeAnswers, answerNullable ) !== -1 ) {
            /*
             * Not nullable
             */
            properties[ columnName ].nullable = false
        } else {
            /*
             * Wrong answer
             */
            askForNullableColumn( columnName )
        }
    }

    function askForUniqueColumn( columnName ) {
        const answerAsUnique = question( 'Define as unique? (y/n) ' ).trim().toLowerCase()

        if ( indexOf( positiveAnswers, answerAsUnique ) !== -1 ) {
            /*
             * Define as unique
             */
            properties[ columnName ].unique = true
        } else if ( indexOf( negativeAnswers, answerAsUnique ) !== -1 ) {
            /*
             * Not unique
             */
            properties[ columnName ].unique = false
        } else {
            /*
             * Wrong answer
             */
            askForUniqueColumn( columnName )
        }
    }

    function createTable() {
        schemaDatabaseService.createTable( tableName, properties )
        .then( () => {
            updateSchema()
        })
        .catch( error => {
            cli.error({
                title: "Error when creating table",
                message: error,
                consequence: "Bundle creation aborted.",
                exit: 0
            })
        })
    }

    function updateSchema() {
        /*
         * We stringify properties and insert it into ~/config/database/schema.js
         */
        checkExistanceOfSchemaFile()
        .then( () => {
            fs.readFile( pathDatabaseSchema, { encoding: 'utf8' }, ( error, data ) => {
                if ( !error ) {
                    const stringToWrite = `export default {\n\t${tableName}: ${JSON.stringify( properties )},\n\n`
                    const dataUpdated = data.replace( /export(\s*)default(\s)\{/i, stringToWrite )

                    fs.writeFile( pathDatabaseSchema, dataUpdated, { encoding: 'utf8' }, error => {
                        if ( !error ) {
                            createBundleDirectory()
                        } else {
                            errorEditingSchema( error )
                        }
                    })
                } else {
                    errorEditingSchema( error )
                }
            })
        })

        function errorEditingSchema( error ) {
            cli.error({
                title: "Impossible to update schema",
                message: `Error when editing schema.js file: ${error}`,
                consequence: "Bundle creation aborted.",
                exit: 0
            })
        }
    }

    function checkExistanceOfSchemaFile() {
        return new Promise( (resolve, reject) => {
            fs.lstat( pathDatabaseSchema, ( error, stat ) => {
                if ( !error & stat.isFile() ) {
                    resolve()
                } else {
                    cli.error({
                        title: "Impossible to update schema",
                        message: `schema.js not found at: ${pathDatabaseSchema}`,
                        consequence: "Bundle creation aborted.",
                        exit: 0
                    })
                }
            })
        })
    }

    function createBundleDirectory() {
        /*
         * Check if new bundle directory is correctly created
         */
        fs.mkdir( bundleCreatingPath, err => {
            if ( err ) {
                cli.error({
                    title: "Impossible to create bundle",
                    message: "Error when trying create bundle directory.",
                    consequence: "Creation aborted.",
                    exit: 0
                })
            } else {
                fs.chmodSync( bundleCreatingPath, parseInt( 777, 8 ) )
                launchWalker()
            }
        })
    }

    function launchWalker() {
        let walker = walk.walk( skeletonBundlePath )

        walker.on( "names", ( root, nodeNamesArray ) => {
            nodeNamesArray.sort( ( a, b ) => {
                if ( a > b ) return 1
                if ( a < b ) return -1
                return 0
            })
        })

        walker.on( "directories", ( root, dirStatsArray, next ) => {
            // dirStatsArray is an array of `stat` objects with the additional attributes
            // * type
            // * error
            // * name
            let newDirName = ''

            for ( let i in dirStatsArray ) {
                newDirName = dirStatsArray[ i ].name.replace( /Skeleton/gi, nameBundleCapitalized )

                fs.mkdir( `${bundleCreatingPath}/${newDirName}`, err => {
                    if ( err ) {
                        cli.error({
                            title: "Impossible to create bundle",
                            message: `Error when trying create bundle sub-directory <${newDirName}>.`,
                            consequence: "Creation aborted.",
                            exit: 0
                        })
                    } else {
                        fs.chmodSync( `${bundleCreatingPath}/${newDirName}`, parseInt( 777, 8 ) )
                    }
                })
            }

            next()
        })

        walker.on( "file", ( root, fileStats, next ) => {
            const skeletonFilePath = path.join( root, fileStats.name )
            const newBundleFilePath = skeletonFilePath.replace( /Skeleton/g, nameBundleCapitalized ).replace( /skeleton/g, nameBundleDecapitalized )

            try {
                let data = fs.readFileSync( skeletonFilePath, 'utf8' )

                /*
                 * We write tableName specified above
                 */
                if ( fileStats.name.toLowerCase().indexOf( 'skeleton.js' ) !== -1 ) {
                    data = data.replace( /tableName(\s*):(\s*)('|")\w*('|")/i, `tableName$1:$2$3${tableName}$4` )
                }

                fs.writeFileSync( newBundleFilePath, data.replace( /Skeleton/g, nameBundleCapitalized ).replace( /skeleton/g, nameBundleDecapitalized ), { encoding: 'utf8' } )
                fs.chmodSync( newBundleFilePath, parseInt( 777, 8 ) )

                next()
            } catch( error ) {
                cli.error({
                    title: "Impossible to create bundle",
                    message: `Error: ${JSON.stringify( error )}`,
                    consequence: "Creation aborted.",
                    exit: 0
                })
            }
        })

        walker.on( "errors", ( root, nodeStatsArray, next ) => {
            next()
        })

        walker.on( "end", () => {
            const answerCreateBundleTests = question( 'Do you want to create tests file? (y/n) ' ).trim().toLowerCase()

            if ( indexOf( positiveAnswers, answerCreateBundleTests ) !== -1 ) {
                /*
                 * Create bundle tests path and file
                 */
                createBundleTestPath()
                .then( () => {
                    exitProgram()
                })
                .catch( error => {
                    cli.error({
                        title: "Error when creating bundle tests file",
                        message: error,
                        consequence: "Bundle tests file creation aborted, however previous operations are completed.",
                        exit: 0
                    })
                })
            } else {
                exitProgram()
            }

        })

    }

    function createBundleTestPath() {
        const newBundleTestsPath = `${bundlesTestPath}/${nameBundleDecapitalized}`

        return new Promise( ( resolve, reject ) => {
            fs.mkdir( newBundleTestsPath, error => {
                if ( error ) {
                    reject( error )
                } else {
                    fs.chmodSync( newBundleTestsPath, parseInt( 777, 8 ) )

                    /*
                     * Now we create test file modeled on that of skeleton
                     */
                    const skeletonBundleTestsFile = `${bundlesTestPath}/skeleton/SkeletonTests.js`

                    fs.readFile( skeletonBundleTestsFile, { encoding: 'utf8' }, ( error, data ) => {
                        if ( error ) {
                            reject( error )
                        } else {
                            /*
                             * Finally we create the file
                             */
                            const newBundleTestsFile = `${newBundleTestsPath}/${nameBundleCapitalized}Tests.js`

                            fs.writeFile( newBundleTestsFile, data.replace( /Skeleton/g, nameBundleCapitalized ).replace( /skeleton/g, nameBundleDecapitalized ), { encoding: 'utf8' }, error => {
                                if ( error ) {
                                    reject( error )
                                } else {
                                    /*
                                     * All is ok!
                                     */
                                    fs.chmodSync( newBundleTestsFile, parseInt( 777, 8 ) )

                                    resolve()
                                }
                            })
                        }
                    })
                }
            })
        })
    }

    function exitProgram() {
        cli.success( `\nBundle ${nameBundleCapitalized} created.\nYou should (re)start build command with "npm run build".\n`, true )
        cli.line()
    }

} else {
    cli.info( "\nCommand: \n[node] createBundle nameOfBundle\n" )
    process.exit()
}
